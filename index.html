<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suleyman Talha Belen | Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Personal website of Suleyman Talha Belen, Electrical and Electronics Engineering student at Bilkent University. Projects, ideas, writings, and papers on signal processing, machine learning, robotics, and optimization."
  />
  <link rel="stylesheet" href="styles.css" />

  <!-- three.js import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <header>
    <div class="nav-container">
      <div class="logo"><a href="index.html">S. T. Belen</a></div>
      <nav>
        <a href="education.html">Education</a>
        <a href="experience.html">Experience</a>
        <a href="projects.html">Projects</a>
        <a href="ideas.html">Ideas</a>
        <a href="writings.html">Writings</a>
        <a href="research.html">Research</a>
        <a href="#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- HERO -->
    <section class="hero reveal" id="hero">
      <div class="hero-left">
        <!-- hover-tilt profile card -->
        <div class="profile-wrapper">
          <div class="profile-card">
            <img src="talha-photo.jpg" alt="Photo of Suleyman Talha Belen" class="profile-photo" />
            <div class="profile-glow"></div>
          </div>
        </div>

        <h1>
          Suleyman Talha Belen<br />
          <span>EEE Student, ML and Robotics Enthusiast</span>
        </h1>
        <p class="hero-subtitle">
          Electrical and Electronics Engineering student at Bilkent University, interested in
          signal processing, machine learning, robotics, reinforcement learning, and optimization.
        </p>
        
        <div class="hero-buttons">
          <a class="btn" href="projects.html">View Projects</a>
          <a class="btn btn-outline" href="ideas.html">Read Ideas</a>
        </div>

        <p class="hero-note">
          This site will gradually host technical notes, project logs, and personal reflections.
        </p>

        <div class="school-logos">
          <span>Studied at:</span>
          <img src="bilkent-logo.png" alt="Bilkent University logo" class="school-logo" />
          <img src="stanford-logo.png" alt="Stanford University logo" class="school-logo" />
          <img src="berkeley-logo.png" alt="UC Berkeley logo" class="school-logo" />
        </div>
      </div>

      <!-- Right: animation + currently info -->
      <div class="hero-right">
        <!-- animation box: made a bit bigger + transparent -->
        <div
          id="stb-anim-box"
          class="stb-anim-box"
          style="background: transparent; box-shadow: none; width: 460px; height: 280px;"
        ></div>

        <div class="hero-panel">
          <h2>Currently</h2>
          <ul>
            <li>üéì B.E. Electrical and Electronics Engineering @ Bilkent University (2027 expected)</li>
            <li>üìç Visiting Student in CS @ Stanford University '25</li>
            <li>üìç Visiting Student in EECS @ UC Berkeley '24</li>
            <li>ü§ñ Exploring research at the intersection of robotics, signal processing, optimization and ML</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- QUICK LINKS -->
    <section class="reveal">
      <h2>Explore</h2>
      <p class="section-subtitle"></p>
      <div class="quick-links">
        <a href="education.html" class="ql-card">
          <h3>Education</h3>
          <p>Bilkent EE, and visiting student experiences at Stanford and UC Berkeley.</p>
        </a>
        <a href="experience.html" class="ql-card">
          <h3>Experience</h3>
          <p>Applied research internship on seismic data visualization at SDT.</p>
        </a>
        <a href="projects.html" class="ql-card">
          <h3>Projects</h3>
          <p>Reinforcement learning, neural fields, and study experiments.</p>
        </a>
        <a href="ideas.html" class="ql-card">
          <h3>Ideas</h3>
          <p>Future directions, concept notes, and open questions.</p>
        </a>
        <a href="research.html" class="ql-card">
          <h3>Research</h3>
          <p>Reading list and future work I would like to publish.</p>
        </a>
        <a href="writings.html" class="ql-card">
          <h3>Writings</h3>
          <p>Personal and technical posts, written mainly for my future self.</p>
        </a>
      </div>
    </section>

    <!-- CONTACT -->
    <section id="contact" class="reveal">
      <h2>Contact</h2>
      <p class="section-subtitle">
        Feel free to reach out about collaborations, internships, or just to say hello.
      </p>
      <ul class="contact-list">
        <li>üìß Email: <a href="mailto:talha.belen@ug.bilkent.edu.tr">talha.belen@ug.bilkent.edu.tr</a></li>
        <li>üíº LinkedIn: <a href="https://www.linkedin.com/in/suleyman-talha-belen-b0645a2a5" target="_blank" rel="noreferrer">linkedin.com/in/suleyman-talha-belen-b0645a2a5</a></li>
        <li>üêô GitHub: <a href="https://github.com/stalhabelen" target="_blank" rel="noreferrer">github.com/stalhabelen</a></li>
      </ul>
    </section>
  </main>

  <footer>
    <span>¬© <span id="year"></span> Suleyman Talha Belen.</span>
    <span
      class="back-to-top"
      onclick="window.scrollTo({ top: 0, behavior: 'smooth' })"
    >
      ‚Üë Back to top
    </span>
  </footer>

  <!-- Year + reveal-on-scroll -->
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const reveals = document.querySelectorAll(".reveal");
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("active");
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.12 }
    );
    reveals.forEach((el) => observer.observe(el));
  </script>

  <!-- Robotic arm grabbing box ‚Üí STB ‚Üí multi-agent loop animation -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const container = document.getElementById('stb-anim-box');
    if (container) {
      // --- CONFIGURATION ---
      const CONFIG = {
        totalParticles: 6000,
        armParticleCount: 5000,
        boxParticleCount: 1000,
        particleSize: 0.28,
        colorBlue: new THREE.Color(0x2563EB),
        colorDark: new THREE.Color(0x1E293B),
        colorAgentRed: new THREE.Color(0xef4444),
        colorMetallic: new THREE.Color(0x94a3b8),
        colorBox: new THREE.Color(0xd97706),
        speed: 0.025,
        holdDuration: 4000
      };

      const STATES = { ARM: 0, TO_STB: 1, STB: 2, TO_AGENTS: 3, AGENTS: 4, TO_ARM: 5 };
      let currentState = STATES.ARM;
      let lastStateChangeTime = Date.now();

      function getSize() {
        const rect = container.getBoundingClientRect();
        return {
          width: rect.width || 460,
          height: rect.height || 280
        };
      }

      const scene = new THREE.Scene();
      let { width, height } = getSize();

      const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      // slightly closer for bigger look
      camera.position.set(0, 8, 26);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const mainLight = new THREE.PointLight(CONFIG.colorBlue, 2, 50);
      mainLight.position.set(15, 20, 15);
      scene.add(mainLight);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.6;
      controls.enableZoom = false;
      controls.target.set(0, 4, 0);

      // --- TARGET ARRAYS ---
      const armLowTargets = [], armLowColors = [];
      const armHighTargets = [], armHighColors = [];
      const stbTargets = [], stbColors = [];
      const agentTargets = [], agentColors = [];

      let currentTargetPositions = [];
      let currentTargetColors = [];

      function addTarget(targetArray, colorArray, vec3, colorObj) {
        targetArray.push(vec3);
        colorArray.push(colorObj.clone());
      }

      // GEOMETRY HELPERS
      function getCylinderPoint(radius, height, centerY, startAngle = 0, endAngle = Math.PI * 2) {
        const angle = startAngle + Math.random() * (endAngle - startAngle);
        const h = (Math.random() - 0.5) * height;
        return new THREE.Vector3(Math.cos(angle) * radius, centerY + h, Math.sin(angle) * radius);
      }
      function getSpherePoint(radius, centerX, centerY, centerZ) {
        const u = Math.random(); const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        return new THREE.Vector3(
          centerX + (radius * Math.sin(phi) * Math.cos(theta)),
          centerY + (radius * Math.sin(phi) * Math.sin(theta)),
          centerZ + (radius * Math.cos(phi))
        );
      }
      function getBoxPoint(cx, cy, cz, size) {
        return new THREE.Vector3(
          cx + (Math.random() - 0.5) * size,
          cy + (Math.random() - 0.5) * size,
          cz + (Math.random() - 0.5) * size
        );
      }

      // 1. ROBOTIC ARM + BOX POSES
      function createRoboticScene(targetsArray, colorsArray, isLiftedPose) {
        let pCount = 0;

        // Base & shoulder
        for (let i = 0; i < 500; i++) { addTarget(targetsArray, colorsArray, getCylinderPoint(3.5, 1.5, -4), CONFIG.colorDark); pCount++; }
        for (let i = 0; i < 300; i++) { addTarget(targetsArray, colorsArray, getSpherePoint(2.2, 0, -2.5, 0), CONFIG.colorDark); pCount++; }

        const lowerArmAngle = isLiftedPose ? Math.PI / 2.5 : Math.PI / 6;
        const upperArmAngleOffset = isLiftedPose ? -Math.PI / 3 : Math.PI / 2.5;

        // Lower arm
        const lowerArmLen = 9;
        const elbowX = Math.cos(lowerArmAngle) * lowerArmLen;
        const elbowY = Math.sin(lowerArmAngle) * lowerArmLen - 2.5;
        for (let i = 0; i < 1300; i++) {
          const t = Math.random();
          const cx = Math.cos(lowerArmAngle) * (t * lowerArmLen);
          const cy = Math.sin(lowerArmAngle) * (t * lowerArmLen) - 2.5;
          const r = 1.6; const a = Math.random() * Math.PI * 2;
          const px = Math.cos(a) * r * 0.8; const py = -Math.cos(a) * r * 0.5;
          const rotX = cx + px * Math.cos(lowerArmAngle) - py * Math.sin(lowerArmAngle);
          const rotY = cy + px * Math.sin(lowerArmAngle) + py * Math.cos(lowerArmAngle);
          const pt = new THREE.Vector3(rotX, rotY, Math.sin(a) * r);
          const col = CONFIG.colorDark.clone().lerp(CONFIG.colorBlue, t);
          addTarget(targetsArray, colorsArray, pt, col); pCount++;
        }

        // Elbow joint
        for (let i = 0; i < 300; i++) {
          addTarget(targetsArray, colorsArray, getSpherePoint(1.8, elbowX, elbowY, 0), CONFIG.colorDark); pCount++;
        }

        // Upper arm
        const upperArmLen = 7;
        const upperArmAbsAngle = lowerArmAngle + upperArmAngleOffset;
        const wristX = elbowX + Math.cos(upperArmAbsAngle) * upperArmLen;
        const wristY = elbowY + Math.sin(upperArmAbsAngle) * upperArmLen;

        for (let i = 0; i < 1000; i++) {
          const t = Math.random();
          const cx = elbowX + Math.cos(upperArmAbsAngle) * (t * upperArmLen);
          const cy = elbowY + Math.sin(upperArmAbsAngle) * (t * upperArmLen);
          const r = 1.4; const a = Math.random() * Math.PI * 2;
          const pt = new THREE.Vector3(cx, cy + Math.cos(a) * r, Math.sin(a) * r);
          const col = CONFIG.colorBlue.clone().lerp(CONFIG.colorDark, t * 0.3);
          addTarget(targetsArray, colorsArray, pt, col); pCount++;
        }

        // Gripper
        const gripperParticles = CONFIG.armParticleCount - pCount;
        for (let i = 0; i < gripperParticles; i++) {
          const side = i % 2 === 0 ? 1 : -1;
          const t = Math.random();
          let fx = wristX + 2 + t * 2.5;
          let fy = wristY + side * 1.8;
          if (isLiftedPose && t > 0.5) fy -= side * (t - 0.5) * 1.0;
          const pt = new THREE.Vector3(fx, fy, (Math.random() - 0.5) * 1.8);
          addTarget(targetsArray, colorsArray, pt, CONFIG.colorMetallic);
        }

        // Box
        let boxCx, boxCy, boxCz;
        if (isLiftedPose) {
          boxCx = wristX + 2.5; boxCy = wristY; boxCz = 0;
        } else {
          boxCx = 10; boxCy = -3; boxCz = 0;
        }
        for (let i = 0; i < CONFIG.boxParticleCount; i++) {
          addTarget(targetsArray, colorsArray, getBoxPoint(boxCx, boxCy, boxCz, 2.5), CONFIG.colorBox);
        }
      }

      createRoboticScene(armLowTargets, armLowColors, false);
      createRoboticScene(armHighTargets, armHighColors, true);

      // 2. STB TEXT
      function createSTBTargets() {
        const letters = {
          S: [[0,1,1,1,1],[1,1,0,0,0],[1,1,1,1,0],[0,0,0,1,1],[1,1,1,1,0]],
          T: [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
          B: [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]]
        };
        let xOffset = -7;
        ['S', 'T', 'B'].forEach((key, index) => {
          const matrix = letters[key];
          for (let r = 0; r < matrix.length; r++) {
            for (let c = 0; c < matrix[0].length; c++) {
              if (matrix[r][c]) {
                const pointsPerPixel = Math.floor(CONFIG.totalParticles / 45);
                for (let i = 0; i < pointsPerPixel; i++) {
                  const pt = new THREE.Vector3(
                    xOffset + c + Math.random() * 0.5,
                    (4 - r) * 1.3 + 3 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 2.5
                  );
                  const mix = index / 2;
                  const col = CONFIG.colorBlue.clone().lerp(CONFIG.colorDark, mix);
                  addTarget(stbTargets, stbColors, pt, col);
                }
              }
            }
          }
          xOffset += 5.5;
        });
      }

      // 3. MULTI-AGENT SWARM
      function createAgentTargets() {
        for (let i = 0; i < CONFIG.totalParticles; i++) {
          const isBlueTeam = i < CONFIG.totalParticles / 2;
          let x, y, z;
          if (isBlueTeam) {
            x = (Math.random() - 1.2) * 7;
            y = (Math.random() - 0.5) * 10;
            z = (Math.random() - 0.5) * 10;
            addTarget(agentTargets, agentColors, new THREE.Vector3(x, y, z), CONFIG.colorBlue);
          } else {
            x = (Math.random() + 0.2) * 7;
            y = (Math.random() - 0.5) * 10;
            z = (Math.random() - 0.5) * 10;
            const col = CONFIG.colorDark.clone().lerp(CONFIG.colorAgentRed, 0.4);
            addTarget(agentTargets, agentColors, new THREE.Vector3(x, y, z), col);
          }
        }
      }

      createSTBTargets();
      createAgentTargets();

      // Make sure every target set has full length
      function ensureLength(targets, colors) {
        while (targets.length < CONFIG.totalParticles && targets.length > 0) {
          const idx = Math.floor(Math.random() * targets.length);
          targets.push(targets[idx].clone());
          colors.push(colors[idx].clone());
        }
      }
      ensureLength(armLowTargets, armLowColors);
      ensureLength(armHighTargets, armHighColors);
      ensureLength(stbTargets, stbColors);
      ensureLength(agentTargets, agentColors);

      // PARTICLE SYSTEM
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(CONFIG.totalParticles * 3);
      const colors = new Float32Array(CONFIG.totalParticles * 3);

      for (let i = 0; i < CONFIG.totalParticles; i++) {
        positions[i * 3]     = armHighTargets[i].x;
        positions[i * 3 + 1] = armHighTargets[i].y;
        positions[i * 3 + 2] = armHighTargets[i].z;
        colors[i * 3]     = armHighColors[i].r;
        colors[i * 3 + 1] = armHighColors[i].g;
        colors[i * 3 + 2] = armHighColors[i].b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const spriteTex = new THREE.TextureLoader().load(
        'https://threejs.org/examples/textures/sprites/disc.png'
      );

      const material = new THREE.PointsMaterial({
        size: CONFIG.particleSize,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        map: spriteTex,
        alphaTest: 0.1,
        blending: THREE.AdditiveBlending
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // ANIMATION LOOP
      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const now = Date.now();
        const elapsed = now - lastStateChangeTime;
        const posAttr = particles.geometry.attributes.position;
        const colAttr = particles.geometry.attributes.color;
        const pArr = posAttr.array;
        const cArr = colAttr.array;

        switch (currentState) {
          case STATES.ARM: {
            const progress = elapsed / CONFIG.holdDuration;
            if (progress < 0.4) {
              currentTargetPositions = armLowTargets;
              currentTargetColors = armLowColors;
            } else {
              currentTargetPositions = armHighTargets;
              currentTargetColors = armHighColors;
            }
            if (elapsed > CONFIG.holdDuration) {
              currentState = STATES.TO_STB;
              lastStateChangeTime = now;
              currentTargetPositions = stbTargets;
              currentTargetColors = stbColors;
            }
            break;
          }
          case STATES.TO_STB:
            if (elapsed > CONFIG.holdDuration * 0.6) {
              currentState = STATES.STB;
              lastStateChangeTime = now;
            }
            break;
          case STATES.STB:
            if (elapsed > CONFIG.holdDuration * 0.8) {
              currentState = STATES.TO_AGENTS;
              lastStateChangeTime = now;
              currentTargetPositions = agentTargets;
              currentTargetColors = agentColors;
            }
            break;
          case STATES.TO_AGENTS:
            if (elapsed > CONFIG.holdDuration * 0.6) {
              currentState = STATES.AGENTS;
              lastStateChangeTime = now;
            }
            break;
          case STATES.AGENTS:
            if (elapsed > CONFIG.holdDuration * 0.8) {
              currentState = STATES.TO_ARM;
              lastStateChangeTime = now;
              currentTargetPositions = armLowTargets;
              currentTargetColors = armLowColors;
            }
            break;
          case STATES.TO_ARM:
            if (elapsed > CONFIG.holdDuration * 0.6) {
              currentState = STATES.ARM;
              lastStateChangeTime = now;
            }
            break;
        }

        for (let i = 0; i < CONFIG.totalParticles; i++) {
          const idx = i * 3;
          const targetPos = currentTargetPositions[i];
          const targetCol = currentTargetColors[i];

          let speed = CONFIG.speed;
          let noise = 0;

          if (currentState === STATES.AGENTS) {
            speed *= 0.15;
            noise = Math.sin(now * 0.005 + pArr[idx] * 0.1) * 0.04;
          } else if (currentState === STATES.STB) {
            speed *= 0.2;
            noise = Math.sin(now * 0.002 + pArr[idx]) * 0.005;
          }

          pArr[idx]     += (targetPos.x - pArr[idx]) * speed + noise;
          pArr[idx + 1] += (targetPos.y - pArr[idx + 1]) * speed + noise;
          pArr[idx + 2] += (targetPos.z - pArr[idx + 2]) * speed;

          cArr[idx]     += (targetCol.r - cArr[idx]) * speed;
          cArr[idx + 1] += (targetCol.g - cArr[idx + 1]) * speed;
          cArr[idx + 2] += (targetCol.b - cArr[idx + 2]) * speed;
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        renderer.render(scene, camera);
      }

      function onResize() {
        const s = getSize();
        width = s.width;
        height = s.height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      window.addEventListener('resize', onResize);
      onResize();
      animate();
    }
  </script>
</body>
</html>