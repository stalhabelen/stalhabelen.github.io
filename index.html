<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suleyman Talha Belen | Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Personal website of Suleyman Talha Belen, Electrical and Electronics Engineering student at Bilkent University. Projects, ideas, writings, and papers on signal processing, machine learning, robotics, and optimization."
  />
  <link rel="stylesheet" href="styles.css" />

  <!-- three.js import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <header>
    <div class="nav-container">
      <div class="logo"><a href="index.html">S. T. Belen</a></div>
      <nav>
        <a href="education.html">Education</a>
        <a href="experience.html">Experience</a>
        <a href="projects.html">Projects</a>
        <a href="ideas.html">Ideas</a>
        <a href="writings.html">Writings</a>
        <a href="research.html">Research</a>
        <a href="#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- HERO -->
    <section class="hero reveal" id="hero">
      <div class="hero-left">
        <div class="profile-wrapper">
          <div class="profile-card">
            <img src="talha-photo.jpg" alt="Photo of Suleyman Talha Belen" class="profile-photo" />
            <div class="profile-glow"></div>
          </div>
        </div>

        <h1>
          Suleyman Talha Belen<br />
          <span>EEE Student, ML and Robotics Enthusiast</span>
        </h1>
        <p class="hero-subtitle">
          Electrical and Electronics Engineering student at Bilkent University, interested in
          signal processing, machine learning, robotics, reinforcement learning, and optimization.
        </p>
        
        <div class="hero-buttons">
          <a class="btn" href="projects.html">View Projects</a>
          <a class="btn btn-outline" href="ideas.html">Read Ideas</a>
        </div>

        <p class="hero-note">
          This site will gradually host technical notes, project logs, and personal reflections.
        </p>

        <div class="school-logos">
          <span>Studied at:</span>
          <img src="bilkent-logo.png" alt="Bilkent University logo" class="school-logo" />
          <img src="stanford-logo.png" alt="Stanford University logo" class="school-logo" />
          <img src="berkeley-logo.png" alt="UC Berkeley logo" class="school-logo" />
        </div>
      </div>

      <!-- Right side: animation + Currently panel -->
      <div class="hero-right">
        <!-- animation container (biraz yukarƒ±da ve b√ºy√ºk) -->
        <div
          id="stb-anim-box"
          class="stb-anim-box"
          style="background: transparent; box-shadow: none; width: 520px; height: 320px; margin-top: -22px; margin-bottom: 18px;"
        ></div>

        <div class="hero-panel">
          <h2>Currently</h2>
          <ul>
            <li>üéì B.E. Electrical and Electronics Engineering @ Bilkent University (2027 expected)</li>
            <li>üìç Visiting Student in CS @ Stanford University '25</li>
            <li>üìç Visiting Student in EECS @ UC Berkeley '24</li>
            <li>ü§ñ Exploring research at the intersection of robotics, signal processing, optimization and ML</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- QUICK LINKS -->
    <section class="reveal">
      <h2>Explore</h2>
      <p class="section-subtitle"></p>
      <div class="quick-links">
        <a href="education.html" class="ql-card">
          <h3>Education</h3>
          <p>Bilkent EE, and visiting student experiences at Stanford and UC Berkeley.</p>
        </a>
        <a href="experience.html" class="ql-card">
          <h3>Experience</h3>
          <p>Applied research internship on seismic data visualization at SDT.</p>
        </a>
        <a href="projects.html" class="ql-card">
          <h3>Projects</h3>
          <p>Reinforcement learning, neural fields, and study experiments.</p>
        </a>
        <a href="ideas.html" class="ql-card">
          <h3>Ideas</h3>
          <p>Future directions, concept notes, and open questions.</p>
        </a>
        <a href="research.html" class="ql-card">
          <h3>Research</h3>
          <p>Reading list and future work I would like to publish.</p>
        </a>
        <a href="writings.html" class="ql-card">
          <h3>Writings</h3>
          <p>Personal and technical posts, written mainly for my future self.</p>
        </a>
      </div>
    </section>

    <!-- CONTACT -->
    <section id="contact" class="reveal">
      <h2>Contact</h2>
      <p class="section-subtitle">
        Feel free to reach out about collaborations, internships, or just to say hello.
      </p>
      <ul class="contact-list">
        <li>üìß Email: <a href="mailto:talha.belen@ug.bilkent.edu.tr">talha.belen@ug.bilkent.edu.tr</a></li>
        <li>üíº LinkedIn: <a href="https://www.linkedin.com/in/suleyman-talha-belen-b0645a2a5" target="_blank" rel="noreferrer">linkedin.com/in/suleyman-talha-belen-b0645a2a5</a></li>
        <li>üêô GitHub: <a href="https://github.com/stalhabelen" target="_blank" rel="noreferrer">github.com/stalhabelen</a></li>
      </ul>
    </section>
  </main>

  <footer>
    <span>¬© <span id="year"></span> Suleyman Talha Belen.</span>
    <span
      class="back-to-top"
      onclick="window.scrollTo({ top: 0, behavior: 'smooth' })"
    >
      ‚Üë Back to top
    </span>
  </footer>

  <!-- year + reveal-on-scroll -->
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const reveals = document.querySelectorAll(".reveal");
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("active");
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.12 }
    );
    reveals.forEach((el) => observer.observe(el));
  </script>

  <!-- Fluid STB & Neural Maze animation (sadece #stb-anim-box i√ßinde) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const container = document.getElementById('stb-anim-box');

    if (container) {
      // --- AYARLAR ---
      const CONFIG = {
        particleCount: 7000,
        particleSize: 0.18,
        colBlue: new THREE.Color(0x2563EB),
        colDark: new THREE.Color(0x0f172a),
        colHighlight: new THREE.Color(0x60a5fa),
        colAgent: new THREE.Color(0xf43f5e),
        speed: 0.02,
        flowSpeed: 0.002
      };

      const STATES = {
        FORM_STB: 0,
        HOLD_STB: 1,
        TO_MAZE: 2,
        MAZE_FLOW: 3,
        TO_RESET: 4
      };

      let currentState = STATES.FORM_STB;
      let lastStateTime = Date.now();

      function getSize() {
        const rect = container.getBoundingClientRect();
        return {
          width: rect.width || 520,
          height: rect.height || 320
        };
      }

      const scene = new THREE.Scene();
      let { width, height } = getSize();

      const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 5, 25);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;
      controls.enableZoom = false;
      controls.target.set(0, 0, 0);

      // --- HEDEF POZƒ∞SYONLAR ---
      const stbTargets = [];  const stbColors = [];
      const mazeTargets = []; const mazeColors = [];

      let currentTargetPositions = [];
      let currentTargetColors = [];

      function getRandomPos() {
        return new THREE.Vector3(
          (Math.random()-0.5)*40,
          (Math.random()-0.5)*20,
          (Math.random()-0.5)*20
        );
      }

      // --- 1. AKI≈ûKAN STB YAZISI ---
      function createFlowingSTB() {
        let curvePoints = [];
        // S
        for (let i = 0; i < 100; i++) {
          const t = i / 100;
          const angle = t * Math.PI * 2 - Math.PI/2;
          const x = Math.cos(angle) * 1.5 - 6.5;
          let y = Math.sin(angle * 1.5) * 2.5;
          if (t < 0.5) y += 1; else y -= 1;
          curvePoints.push({x, y, z: 0, letter: 'S'});
        }
        // T top
        for (let i = 0; i < 50; i++) {
          curvePoints.push({x: -1.5 + (i/50)*3, y: 3.5, z: 0, letter: 'T'});
        }
        // T vertical
        for (let i = 0; i < 80; i++) {
          curvePoints.push({x: 0, y: 3.5 - (i/80)*5.5, z: 0, letter: 'T'});
        }
        // B
        const bOffset = 5.0;
        for (let i = 0; i < 80; i++) {
          curvePoints.push({x: bOffset, y: 3.5 - (i/80)*5.5, z: 0, letter: 'B'});
        }
        // upper arc
        for (let i = 0; i < 50; i++) {
          const angle = (i/50) * Math.PI - Math.PI/2;
          curvePoints.push({x: bOffset + Math.cos(angle)*1.5, y: 2.0 + Math.sin(angle)*1.5, z: 0, letter: 'B'});
        }
        // lower arc
        for (let i = 0; i < 50; i++) {
          const angle = (i/50) * Math.PI - Math.PI/2;
          curvePoints.push({x: bOffset + Math.cos(angle)*1.8, y: -0.8 + Math.sin(angle)*1.8, z: 0, letter: 'B'});
        }

        for (let i = 0; i < CONFIG.particleCount; i++) {
          const base = curvePoints[Math.floor(Math.random() * curvePoints.length)];
          const spread = 0.35;
          const tx = base.x + (Math.random()-0.5) * spread;
          const ty = base.y + (Math.random()-0.5) * spread;
          const tz = base.z + (Math.random()-0.5) * spread * 2;
          stbTargets.push(new THREE.Vector3(tx, ty, tz));
          const isBright = Math.random() > 0.8;
          stbColors.push(isBright ? CONFIG.colHighlight.clone() : CONFIG.colBlue.clone());
        }
      }
      createFlowingSTB();

      // --- 2. COMPLEX NEURAL MAZE ---
      function createMazeTargets() {
        const size = 18;
        const levels = 3;
        let wallPoints = [];
        let pathPoints = [];

        for (let y = 0; y < levels; y++) {
          const levelHeight = (y - 1) * 4;
          for (let x = -size/2; x < size/2; x += 0.8) {
            for (let z = -size/2; z < size/2; z += 0.8) {
              const noise = Math.sin(x*0.5) * Math.cos(z*0.5);
              if (noise > 0.2) {
                if (Math.random() > 0.6) {
                  wallPoints.push(new THREE.Vector3(
                    x,
                    levelHeight + (Math.random()-0.5)*2,
                    z
                  ));
                }
              } else {
                if (Math.random() > 0.95) {
                  pathPoints.push(new THREE.Vector3(x, levelHeight, z));
                }
              }
            }
          }
        }

        let wIndex = 0;
        let pIndex = 0;

        for (let i = 0; i < CONFIG.particleCount; i++) {
          const isAgent = i > CONFIG.particleCount * 0.85;
          if (isAgent && pathPoints.length > 0) {
            const p = pathPoints[pIndex % pathPoints.length];
            mazeTargets.push(new THREE.Vector3(
              p.x + (Math.random()-0.5),
              p.y,
              p.z + (Math.random()-0.5)
            ));
            mazeColors.push(CONFIG.colAgent.clone());
            pIndex++;
          } else {
            if (wallPoints.length > 0) {
              const w = wallPoints[wIndex % wallPoints.length];
              mazeTargets.push(new THREE.Vector3(w.x, w.y, w.z));
              const dist = Math.sqrt(w.x*w.x + w.z*w.z);
              const darkness = Math.min(1, dist / 15);
              const col = CONFIG.colBlue.clone().lerp(CONFIG.colDark, darkness);
              mazeColors.push(col);
              wIndex++;
            } else {
              mazeTargets.push(new THREE.Vector3(0, 0, 0));
              mazeColors.push(CONFIG.colDark.clone());
            }
          }
        }
      }
      createMazeTargets();

      // --- PAR√áACIK Sƒ∞STEMƒ∞ ---
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(CONFIG.particleCount * 3);
      const colors = new Float32Array(CONFIG.particleCount * 3);
      const phases = new Float32Array(CONFIG.particleCount);

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const pos = getRandomPos();
        positions[i*3]     = pos.x;
        positions[i*3 + 1] = pos.y;
        positions[i*3 + 2] = pos.z;

        colors[i*3]     = CONFIG.colBlue.r;
        colors[i*3 + 1] = CONFIG.colBlue.g;
        colors[i*3 + 2] = CONFIG.colBlue.b;

        phases[i] = Math.random() * Math.PI * 2;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

      const sprite = new THREE.TextureLoader().load(
        'https://threejs.org/examples/textures/sprites/spark1.png'
      );

      const material = new THREE.PointsMaterial({
        size: CONFIG.particleSize,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        map: sprite,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Ba≈ülangƒ±√ß hedefi STB olsun
      currentTargetPositions = stbTargets;
      currentTargetColors = stbColors;

      // --- ANIMASYON ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const now = Date.now();
        const elapsed = now - lastStateTime;
        const posAttr = particles.geometry.attributes.position;
        const colAttr = particles.geometry.attributes.color;
        const phaseAttr = particles.geometry.attributes.phase;

        const pArr = posAttr.array;
        const cArr = colAttr.array;
        const phArr = phaseAttr.array;

        switch (currentState) {
          case STATES.FORM_STB:
            currentTargetPositions = stbTargets;
            currentTargetColors = stbColors;
            if (elapsed > 3000) {
              currentState = STATES.HOLD_STB;
              lastStateTime = now;
            }
            break;
          case STATES.HOLD_STB:
            // hedef deƒüi≈ümiyor
            if (elapsed > 4000) {
              currentState = STATES.TO_MAZE;
              lastStateTime = now;
            }
            break;
          case STATES.TO_MAZE:
            currentTargetPositions = mazeTargets;
            currentTargetColors = mazeColors;
            if (elapsed > 3000) {
              currentState = STATES.MAZE_FLOW;
              lastStateTime = now;
            }
            break;
          case STATES.MAZE_FLOW:
            if (elapsed > 6000) {
              currentState = STATES.TO_RESET;
              lastStateTime = now;
            }
            break;
          case STATES.TO_RESET:
            currentTargetPositions = stbTargets;
            currentTargetColors = stbColors;
            if (elapsed > 3000) {
              currentState = STATES.HOLD_STB;
              lastStateTime = now;
            }
            break;
        }

        const time = now * 0.001;

        for (let i = 0; i < CONFIG.particleCount; i++) {
          const ix = i * 3;

          const tx = currentTargetPositions[i].x;
          const ty = currentTargetPositions[i].y;
          const tz = currentTargetPositions[i].z;

          const tr = currentTargetColors[i].r;
          const tg = currentTargetColors[i].g;
          const tb = currentTargetColors[i].b;

          let speed = CONFIG.speed;
          let waveX = 0, waveY = 0, waveZ = 0;

          if (currentState === STATES.HOLD_STB || currentState === STATES.FORM_STB) {
            const p = phArr[i];
            waveX = Math.sin(time * 2 + p) * 0.05;
            waveY = Math.cos(time * 3 + p) * 0.05;
            waveZ = Math.sin(time * 1.5 + p) * 0.05;
          } else if (currentState === STATES.MAZE_FLOW || currentState === STATES.TO_MAZE) {
            const isAgent = (cArr[ix] < 0.4 && cArr[ix+1] < 0.4 && cArr[ix+2] < 0.4) === false &&
                            (cArr[ix] > 0.5 && cArr[ix+2] < 0.3); // kabaca "kƒ±rmƒ±zƒ±"
            if (isAgent) {
              speed = 0.05;
              if (i % 2 === 0) waveX = Math.sin(time * 10 + i) * 0.5;
              else waveZ = Math.cos(time * 10 + i) * 0.5;
            } else {
              speed = 0.02;
              waveY = Math.sin(time + phArr[i]) * 0.02;
            }
          } else if (currentState === STATES.STB) {
            waveX = Math.sin(time * 2 + phArr[i]) * 0.03;
            waveY = Math.cos(time * 2 + phArr[i]) * 0.03;
          }

          // Pozisyon g√ºncelle
          pArr[ix]     += (tx - pArr[ix]) * speed + waveX;
          pArr[ix + 1] += (ty - pArr[ix + 1]) * speed + waveY;
          pArr[ix + 2] += (tz - pArr[ix + 2]) * speed + waveZ;

          // Renk g√ºncelle
          cArr[ix]     += (tr - cArr[ix]) * speed;
          cArr[ix + 1] += (tg - cArr[ix + 1]) * speed;
          cArr[ix + 2] += (tb - cArr[ix + 2]) * speed;
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        renderer.render(scene, camera);
      }

      function onResize() {
        const s = getSize();
        width = s.width;
        height = s.height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      window.addEventListener('resize', onResize);
      onResize();
      animate();
    }
  </script>
</body>
</html>