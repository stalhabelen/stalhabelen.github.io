<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suleyman Talha Belen | Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Personal website of Suleyman Talha Belen, Electrical and Electronics Engineering student at Bilkent University. Projects, ideas, writings, and papers on signal processing, machine learning, robotics, and optimization."
  />
  <link rel="stylesheet" href="styles.css" />

  <!-- three.js import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <header>
    <div class="nav-container">
      <div class="logo"><a href="index.html">S. T. Belen</a></div>
      <nav>
        <a href="education.html">Education</a>
        <a href="experience.html">Experience</a>
        <a href="projects.html">Projects</a>
        <a href="ideas.html">Ideas</a>
        <a href="writings.html">Writings</a>
        <a href="research.html">Research</a>
        <a href="#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- HERO -->
    <section class="hero reveal" id="hero">
      <div class="hero-left">
        <!-- hover-tilt profile card -->
        <div class="profile-wrapper">
          <div class="profile-card">
            <img src="talha-photo.jpg" alt="Photo of Suleyman Talha Belen" class="profile-photo" />
            <div class="profile-glow"></div>
          </div>
        </div>

        <h1>
          Suleyman Talha Belen<br />
          <span>EEE Student, ML and Robotics Enthusiast</span>
        </h1>
        <p class="hero-subtitle">
          Electrical and Electronics Engineering student at Bilkent University, interested in
          signal processing, machine learning, robotics, reinforcement learning, and optimization.
        </p>
        
        <div class="hero-buttons">
          <a class="btn" href="projects.html">View Projects</a>
          <a class="btn btn-outline" href="ideas.html">Read Ideas</a>
        </div>

        <p class="hero-note">
          This site will gradually host technical notes, project logs, and personal reflections.
        </p>

        <div class="school-logos">
          <span>Studied at:</span>
          <img src="bilkent-logo.png" alt="Bilkent University logo" class="school-logo" />
          <img src="stanford-logo.png" alt="Stanford University logo" class="school-logo" />
          <img src="berkeley-logo.png" alt="UC Berkeley logo" class="school-logo" />
        </div>
      </div>

      <!-- Right side: animation + Currently panel -->
      <div class="hero-right">
        <!-- animation card; slightly bigger, a bit higher -->
        <div
          id="stb-anim-box"
          class="stb-anim-box"
          style="background: transparent; box-shadow: none; width: 500px; height: 310px; margin-top: -18px; margin-bottom: 18px;"
        ></div>

        <div class="hero-panel">
          <h2>Currently</h2>
          <ul>
            <li>üéì B.E. Electrical and Electronics Engineering @ Bilkent University (2027 expected)</li>
            <li>üìç Visiting Student in CS @ Stanford University '25</li>
            <li>üìç Visiting Student in EECS @ UC Berkeley '24</li>
            <li>ü§ñ Exploring research at the intersection of robotics, signal processing, optimization and ML</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- QUICK LINKS -->
    <section class="reveal">
      <h2>Explore</h2>
      <p class="section-subtitle"></p>
      <div class="quick-links">
        <a href="education.html" class="ql-card">
          <h3>Education</h3>
          <p>Bilkent EE, and visiting student experiences at Stanford and UC Berkeley.</p>
        </a>
        <a href="experience.html" class="ql-card">
          <h3>Experience</h3>
          <p>Applied research internship on seismic data visualization at SDT.</p>
        </a>
        <a href="projects.html" class="ql-card">
          <h3>Projects</h3>
          <p>Reinforcement learning, neural fields, and study experiments.</p>
        </a>
        <a href="ideas.html" class="ql-card">
          <h3>Ideas</h3>
          <p>Future directions, concept notes, and open questions.</p>
        </a>
        <a href="research.html" class="ql-card">
          <h3>Research</h3>
          <p>Reading list and future work I would like to publish.</p>
        </a>
        <a href="writings.html" class="ql-card">
          <h3>Writings</h3>
          <p>Personal and technical posts, written mainly for my future self.</p>
        </a>
      </div>
    </section>

    <!-- CONTACT -->
    <section id="contact" class="reveal">
      <h2>Contact</h2>
      <p class="section-subtitle">
        Feel free to reach out about collaborations, internships, or just to say hello.
      </p>
      <ul class="contact-list">
        <li>üìß Email: <a href="mailto:talha.belen@ug.bilkent.edu.tr">talha.belen@ug.bilkent.edu.tr</a></li>
        <li>üíº LinkedIn: <a href="https://www.linkedin.com/in/suleyman-talha-belen-b0645a2a5" target="_blank" rel="noreferrer">linkedin.com/in/suleyman-talha-belen-b0645a2a5</a></li>
        <li>üêô GitHub: <a href="https://github.com/stalhabelen" target="_blank" rel="noreferrer">github.com/stalhabelen</a></li>
      </ul>
    </section>
  </main>

  <footer>
    <span>¬© <span id="year"></span> Suleyman Talha Belen.</span>
    <span
      class="back-to-top"
      onclick="window.scrollTo({ top: 0, behavior: 'smooth' })"
    >
      ‚Üë Back to top
    </span>
  </footer>

  <!-- year + reveal-on-scroll -->
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const reveals = document.querySelectorAll(".reveal");
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("active");
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.12 }
    );
    reveals.forEach((el) => observer.observe(el));
  </script>

  <!-- Ultimate Robotic Arm & AI animation, mounted only into #stb-anim-box -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const container = document.getElementById('stb-anim-box');

    if (container) {
      // --- KONFƒ∞G√úRASYON ---
      const CONFIG = {
        totalParticles: 8000,
        armParticles: 6000,
        boxParticles: 800,
        particleSize: 0.24,
        colRobotBody: new THREE.Color(0xf97316),
        colRobotJoint: new THREE.Color(0x1E293B),
        colMetallic: new THREE.Color(0x94a3b8),
        colBox: new THREE.Color(0x3b82f6),
        colMazeWall: new THREE.Color(0x0f172a),
        colMazeAgent: new THREE.Color(0xe11d48),
        colSTB: new THREE.Color(0x2563EB),
        speed: 0.035
      };

      const STATES = { 
        INIT: 0,
        GRAB_DOWN: 1,
        LIFT_UP: 2,
        TO_STB: 3,
        STB: 4,
        TO_MAZE: 5,
        MAZE: 6,
        TO_RESET: 7
      };

      let currentState = STATES.GRAB_DOWN;
      let lastStateTime = Date.now();

      function getSize() {
        const rect = container.getBoundingClientRect();
        return {
          width: rect.width || 500,
          height: rect.height || 310
        };
      }

      const scene = new THREE.Scene();
      let { width, height } = getSize();

      const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 12, 35);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const light = new THREE.PointLight(0xffffff, 1.5, 60);
      light.position.set(10, 20, 20);
      scene.add(light);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;
      controls.enableZoom = false;
      controls.target.set(0, 4, 0);

      // --- HEDEF KOORDƒ∞NAT Dƒ∞Zƒ∞LERƒ∞ ---
      const targetPos = { grab: [], lift: [], stb: [], maze: [] };
      const targetCol = { grab: [], lift: [], stb: [], maze: [] };

      let activeTargets = [];
      let activeColors = [];

      function pushPoint(type, vec, col) {
        targetPos[type].push(vec);
        targetCol[type].push(col.clone());
      }

      // --- ROBOT KOLU MODELLEMESƒ∞ (GRAB & LIFT) ---
      function createRobotPose(type, isLifting) {
        const isUp = isLifting;
        let pCount = 0;

        const angleShoulder = isUp ? -Math.PI / 3 : Math.PI / 6; 
        const angleElbow = isUp ? -Math.PI / 2 : Math.PI / 1.5;

        const hBase = 3.5;
        const lUpper = 9;
        const lLower = 8;

        const pShoulder = new THREE.Vector3(0, hBase, 0);
        const pElbow = new THREE.Vector3(
          0,
          pShoulder.y + Math.cos(angleShoulder) * lUpper,
          pShoulder.z + Math.sin(angleShoulder) * lUpper
        );
        const pWrist = new THREE.Vector3(
          0,
          pElbow.y + Math.cos(angleShoulder + angleElbow) * lLower,
          pElbow.z + Math.sin(angleShoulder + angleElbow) * lLower
        );

        // Base
        for (let i = 0; i < 600; i++) {
          const r = Math.random() * 3; 
          const h = (Math.random()) * 3 - 3;
          const vec = new THREE.Vector3((Math.random()-0.5)*r*2, h, (Math.random()-0.5)*r*2);
          const col = (r > 2.5) ? CONFIG.colRobotBody : CONFIG.colRobotJoint;
          pushPoint(type, vec, col); pCount++;
        }

        // Shoulder joint
        for (let i = 0; i < 400; i++) {
          const vec = new THREE.Vector3(
            (Math.random()-0.5)*3,
            pShoulder.y + (Math.random()-0.5)*2,
            (Math.random()-0.5)*3
          );
          pushPoint(type, vec, CONFIG.colRobotJoint); pCount++;
        }

        // Upper arm
        for (let i = 0; i < 1500; i++) {
          const t = Math.random();
          const center = new THREE.Vector3().lerpVectors(pShoulder, pElbow, t);
          const thickness = 1.5 + Math.sin(t * Math.PI) * 0.8;
          const r = (Math.random() - 0.5) * thickness;
          const r2 = (Math.random() - 0.5) * thickness;
          center.x += r; center.z += r2;
          pushPoint(type, center, CONFIG.colRobotBody); pCount++;
        }

        // Elbow joint
        for (let i = 0; i < 400; i++) {
          const vec = new THREE.Vector3(
            (Math.random()-0.5)*2.5,
            pElbow.y + (Math.random()-0.5)*2,
            pElbow.z + (Math.random()-0.5)*2
          );
          pushPoint(type, vec, CONFIG.colRobotJoint); pCount++;
        }

        // Forearm
        for (let i = 0; i < 1400; i++) {
          const t = Math.random();
          const center = new THREE.Vector3().lerpVectors(pElbow, pWrist, t);
          const thickness = 1.2 + Math.sin(t * Math.PI) * 0.5;
          center.x += (Math.random()-0.5)*thickness;
          center.y += (Math.random()-0.5)*thickness;
          pushPoint(type, center, CONFIG.colRobotBody); pCount++;
        }

        // Gripper
        const gripDir = new THREE.Vector3().subVectors(pWrist, pElbow).normalize();
        const pGripEnd = pWrist.clone().add(gripDir.multiplyScalar(3));
        const gripParticles = CONFIG.armParticles - pCount;
        for (let i = 0; i < gripParticles; i++) {
          const t = Math.random();
          const center = new THREE.Vector3().lerpVectors(pWrist, pGripEnd, t);
          const fork = (Math.random() > 0.5 ? 1 : -1) * (isUp ? 0.5 : 1.5);
          center.x += fork * t; 
          pushPoint(type, center, CONFIG.colMetallic);
        }

        // Box
        let boxPos;
        if (isUp) {
          boxPos = pGripEnd.clone();
        } else {
          boxPos = new THREE.Vector3(0, -3, 11);
        }

        for (let i = 0; i < CONFIG.boxParticles; i++) {
          const bVec = new THREE.Vector3(
            boxPos.x + (Math.random()-0.5)*3.5,
            boxPos.y + (Math.random()-0.5)*3.5,
            boxPos.z + (Math.random()-0.5)*3.5
          );
          pushPoint(type, bVec, CONFIG.colBox);
        }
      }

      createRobotPose('grab', false);
      createRobotPose('lift', true);

      // --- STB ---
      function createSTB() {
        const letters = { 
          S: [[0,1,1,1,1],[1,1,0,0,0],[1,1,1,1,0],[0,0,0,1,1],[1,1,1,1,0]], 
          T: [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]], 
          B: [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]] 
        };
        let xOffset = -7;
        const particlesPerDot = Math.floor(CONFIG.totalParticles / 45); 
        ['S', 'T', 'B'].forEach((key) => {
          const matrix = letters[key];
          for (let r = 0; r < matrix.length; r++) {
            for (let c = 0; c < matrix[0].length; c++) {
              if (matrix[r][c]) {
                for (let k = 0; k < particlesPerDot; k++) {
                  const vec = new THREE.Vector3(
                    xOffset + c + (Math.random()-0.5)*0.6,
                    (4-r)*1.5 + 3 + (Math.random()-0.5)*0.6,
                    (Math.random()-0.5)*2
                  );
                  pushPoint('stb', vec, CONFIG.colSTB);
                }
              }
            }
          }
          xOffset += 6;
        });
        while (targetPos.stb.length < CONFIG.totalParticles) {
          const idx = Math.floor(Math.random() * targetPos.stb.length);
          pushPoint('stb', targetPos.stb[idx], targetCol.stb[idx]);
        }
      }
      createSTB();

      // --- MAZE ---
      function createMaze() {
        const map = [
          [1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,1,0,0,0,0,0,1],
          [1,0,1,1,1,0,1,1,1,0,1],
          [1,0,1,0,0,0,0,0,1,0,1],
          [1,0,1,0,1,1,1,0,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,1],
          [1,1,1,0,1,0,1,0,1,1,1],
          [1,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1]
        ];
        const rows = map.length;
        const cols = map[0].length;
        const scale = 3.5;
        const wallHeight = 2.5;

        let wallCells = [];
        let pathCells = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (map[r][c] === 1) wallCells.push({r,c});
            else pathCells.push({r,c});
          }
        }

        const total = CONFIG.totalParticles;
        const wallLimit = Math.floor(total * 0.75);
        
        for (let i = 0; i < wallLimit; i++) {
          const cell = wallCells[Math.floor(Math.random()*wallCells.length)];
          const vec = new THREE.Vector3(
            (cell.c - cols/2) * scale + (Math.random()-0.5)*scale,
            (Math.random()-0.5) * wallHeight,
            (cell.r - rows/2) * scale + (Math.random()-0.5)*scale
          );
          pushPoint('maze', vec, CONFIG.colMazeWall);
        }

        for (let i = wallLimit; i < total; i++) {
          const cell = pathCells[Math.floor(Math.random()*pathCells.length)];
          const vec = new THREE.Vector3(
            (cell.c - cols/2) * scale + (Math.random()-0.5)*(scale*0.8),
            (Math.random()-0.5) * 1.0,
            (cell.r - rows/2) * scale + (Math.random()-0.5)*(scale*0.8)
          );
          pushPoint('maze', vec, CONFIG.colMazeAgent);
        }
      }
      createMaze();

      // target dizilerinin hepsi totalParticles uzunluƒüunda olsun
      function ensureLength(name) {
        const arrP = targetPos[name];
        const arrC = targetCol[name];
        while (arrP.length < CONFIG.totalParticles && arrP.length > 0) {
          const idx = Math.floor(Math.random() * arrP.length);
          arrP.push(arrP[idx].clone());
          arrC.push(arrC[idx].clone());
        }
      }
      ensureLength('grab');
      ensureLength('lift');
      ensureLength('maze');

      // --- PAR√áACIK Sƒ∞STEMƒ∞ BA≈ûLATMA ---
      const geometry = new THREE.BufferGeometry();
      const posArray = new Float32Array(CONFIG.totalParticles * 3);
      const colArray = new Float32Array(CONFIG.totalParticles * 3);

      for (let i = 0; i < CONFIG.totalParticles; i++) {
        const p = targetPos.grab[i];
        const c = targetCol.grab[i];
        posArray[i*3]     = p.x;
        posArray[i*3 + 1] = p.y;
        posArray[i*3 + 2] = p.z;
        colArray[i*3]     = c.r;
        colArray[i*3 + 1] = c.g;
        colArray[i*3 + 2] = c.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

      const sprite = new THREE.TextureLoader().load(
        'https://threejs.org/examples/textures/sprites/disc.png'
      );

      const material = new THREE.PointsMaterial({
        size: CONFIG.particleSize,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        map: sprite,
        alphaTest: 0.1,
        blending: THREE.AdditiveBlending
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      activeTargets = targetPos.grab;
      activeColors = targetCol.grab;

      // --- ANIMASYON LOOP ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const now = Date.now();
        const elapsed = now - lastStateTime;
        const positions = particles.geometry.attributes.position.array;
        const colors = particles.geometry.attributes.color.array;

        switch (currentState) {
          case STATES.GRAB_DOWN:
            activeTargets = targetPos.grab; activeColors = targetCol.grab;
            if (elapsed > 2000) { currentState = STATES.LIFT_UP; lastStateTime = now; }
            break;
          case STATES.LIFT_UP:
            activeTargets = targetPos.lift; activeColors = targetCol.lift;
            if (elapsed > 3500) { currentState = STATES.TO_STB; lastStateTime = now; }
            break;
          case STATES.TO_STB:
            activeTargets = targetPos.stb; activeColors = targetCol.stb;
            if (elapsed > 2500) { currentState = STATES.STB; lastStateTime = now; }
            break;
          case STATES.STB:
            if (elapsed > 3000) { currentState = STATES.TO_MAZE; lastStateTime = now; }
            break;
          case STATES.TO_MAZE:
            activeTargets = targetPos.maze; activeColors = targetCol.maze;
            if (elapsed > 2500) { currentState = STATES.MAZE; lastStateTime = now; }
            break;
          case STATES.MAZE:
            if (elapsed > 5000) { currentState = STATES.TO_RESET; lastStateTime = now; }
            break;
          case STATES.TO_RESET:
            activeTargets = targetPos.grab; activeColors = targetCol.grab;
            if (elapsed > 2500) { currentState = STATES.GRAB_DOWN; lastStateTime = now; }
            break;
        }

        for (let i = 0; i < CONFIG.totalParticles; i++) {
          const ix = i * 3;
          const tPos = activeTargets[i];
          const tCol = activeColors[i];
          const tx = tPos.x, ty = tPos.y, tz = tPos.z;
          const tr = tCol.r, tg = tCol.g, tb = tCol.b;

          let speed = CONFIG.speed;
          let noise = 0;

          if (currentState === STATES.LIFT_UP || currentState === STATES.GRAB_DOWN) {
            speed = 0.04;
          } else if (currentState === STATES.MAZE) {
            speed = 0.02;
            if (colors[ix] > 0.8 && colors[ix+2] < 0.2) { 
              noise = Math.sin(now * 0.005 + i) * 0.03;
              if (i % 2 === 0) positions[ix] += Math.cos(now * 0.002) * 0.02;
              else positions[ix+2] += Math.sin(now * 0.002) * 0.02;
            }
          } else if (currentState === STATES.STB) {
            noise = Math.sin(now * 0.002 + positions[ix]) * 0.005;
          }

          positions[ix]     += (tx - positions[ix]) * speed + noise;
          positions[ix + 1] += (ty - positions[ix + 1]) * speed + noise;
          positions[ix + 2] += (tz - positions[ix + 2]) * speed;

          colors[ix]     += (tr - colors[ix]) * speed;
          colors[ix + 1] += (tg - colors[ix + 1]) * speed;
          colors[ix + 2] += (tb - colors[ix + 2]) * speed;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
      }

      function onResize() {
        const s = getSize();
        width = s.width;
        height = s.height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      window.addEventListener('resize', onResize);
      onResize();
      animate();
    }
  </script>
</body>
</html>