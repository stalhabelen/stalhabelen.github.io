<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suleyman Talha Belen | Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Personal website of Suleyman Talha Belen, Electrical and Electronics Engineering student at Bilkent University. Projects, ideas, writings, and papers on signal processing, machine learning, robotics, and optimization."
  />

  <link rel="stylesheet" href="styles.css" />

  <!-- three.js importmap for animation -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <header>
    <div class="nav-container">
      <div class="logo"><a href="index.html">S. T. Belen</a></div>
      <nav>
        <a href="education.html">Education</a>
        <a href="experience.html">Experience</a>
        <a href="projects.html">Projects</a>
        <a href="ideas.html">Ideas</a>
        <a href="writings.html">Writings</a>
        <a href="research.html">Research</a>
        <a href="#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- HERO -->
    <section class="hero reveal" id="hero">
      <div class="hero-left">
        <!-- hover-tilt profile card -->
        <div class="profile-wrapper">
          <div class="profile-card">
            <img src="talha-photo.jpg" alt="Photo of Suleyman Talha Belen" class="profile-photo" />
            <div class="profile-glow"></div>
          </div>
        </div>

        <h1>
          Suleyman Talha Belen<br />
          <span>EEE Student, ML and Robotics Enthusiast</span>
        </h1>
        <p class="hero-subtitle">
          Electrical and Electronics Engineering student at Bilkent University, interested in
          signal processing, machine learning, robotics, reinforcement learning, and optimization.
        </p>

        <div class="hero-buttons">
          <a class="btn" href="projects.html">View Projects</a>
          <a class="btn btn-outline" href="ideas.html">Read Ideas</a>
        </div>

        <p class="hero-note">
          This site will gradually host technical notes, project logs, and personal reflections.
        </p>

        <div class="school-logos">
          <span>Studied at:</span>
          <img src="bilkent-logo.png" alt="Bilkent University logo" class="school-logo" />
          <img src="stanford-logo.png" alt="Stanford University logo" class="school-logo" />
          <img src="berkeley-logo.png" alt="UC Berkeley logo" class="school-logo" />
        </div>
      </div>

      <!-- RIGHT SIDE: ONLY ANIMATION, NO TEXT, NO NAVY BG -->
      <div class="hero-right" style="background: transparent; box-shadow: none;">
        <div
          id="stb-anim-box"
          class="stb-anim-box"
          style="width:100%; height:260px; background: transparent; box-shadow:none; border-radius:0;"
        ></div>
      </div>

      <div class="hero-panel">
        <h2>Currently</h2>
        <ul>
          <li>üéì B.E. Electrical and Electronics Engineering @ Bilkent University (2027 expected)</li>
          <li>üìç Visiting Student in CS @ Stanford University '25</li>
          <li>üìç Visiting Student in EECS @ UC Berkeley '24</li>
          <li>ü§ñ Exploring research at the intersection of robotics, signal processing, optimization and ML</li>
        </ul>
      </div>
    </section>

    <!-- QUICK LINKS -->
    <section class="reveal">
      <h2>Explore</h2>
      <div class="quick-links">
        <a href="education.html" class="ql-card">
          <h3>Education</h3>
          <p>Bilkent EE, and visiting student experiences at Stanford and UC Berkeley.</p>
        </a>
        <a href="experience.html" class="ql-card">
          <h3>Experience</h3>
          <p>Applied research internship on seismic data visualization at SDT.</p>
        </a>
        <a href="projects.html" class="ql-card">
          <h3>Projects</h3>
          <p>Reinforcement learning, neural fields, and study experiments.</p>
        </a>
        <a href="ideas.html" class="ql-card">
          <h3>Ideas</h3>
          <p>Future directions, concept notes, and open questions.</p>
        </a>
        <a href="research.html" class="ql-card">
          <h3>Research</h3>
          <p>Reading list and future work I would like to publish.</p>
        </a>
        <a href="writings.html" class="ql-card">
          <h3>Writings</h3>
          <p>Personal and technical posts, written mainly for my future self.</p>
        </a>
      </div>
    </section>

    <!-- CONTACT -->
    <section id="contact" class="reveal">
      <h2>Contact</h2>
      <p class="section-subtitle">
        Feel free to reach out about collaborations, internships, or just to say hello.
      </p>
      <ul class="contact-list">
        <li>üìß Email: <a href="mailto:talha.belen@ug.bilkent.edu.tr">talha.belen@ug.bilkent.edu.tr</a></li>
        <li>üíº LinkedIn: <a href="https://www.linkedin.com/in/suleyman-talha-belen-b0645a2a5" target="_blank" rel="noreferrer">linkedin.com/in/suleyman-talha-belen-b0645a2a5</a></li>
        <li>üêô GitHub: <a href="https://github.com/stalhabelen" target="_blank" rel="noreferrer">github.com/stalhabelen</a></li>
      </ul>
    </section>
  </main>

  <footer>
    <span>¬© <span id="year"></span> Suleyman Talha Belen.</span>
    <span
      class="back-to-top"
      onclick="window.scrollTo({ top: 0, behavior: 'smooth' })"
    >
      ‚Üë Back to top
    </span>
  </footer>

  <!-- Scroll reveal + year -->
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const reveals = document.querySelectorAll(".reveal");
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("active");
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.12 }
    );
    reveals.forEach((el) => observer.observe(el));
  </script>

  <!-- CLEAR STB & STRUCTURED MAZE ANIMATION (SCOPED TO stb-anim-box) -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // --- AYARLAR ---
    const CONFIG = {
      particleCount: 9000,
      particleSize: 0.22,
      colBlue: new THREE.Color(0x2563eb),
      colDarkBlue: new THREE.Color(0x1e3a8a),
      colAgent: new THREE.Color(0xff2244),
      speed: 0.03
    };

    const STATES = {
      FORM_STB: 0,
      HOLD_STB: 1,
      TO_MAZE: 2,
      MAZE_ACTIVE: 3,
      TO_RESET: 4
    };

    let currentState = STATES.FORM_STB;
    let lastStateTime = Date.now();

    // Container boyutu (sadece kart i√ßinde)
    const container = document.getElementById("stb-anim-box");
    function getSize() {
      const w = container.clientWidth || 480;
      const h = container.clientHeight || 260;
      return { w, h };
    }
    let { w, h } = getSize();

    // --- SAHNE KURULUMU ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 1000);
    camera.position.set(0, 12, 28);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setClearColor(0x000000, 0);
    renderer.setSize(w, h);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.4;
    controls.target.set(0, 2, 0);

    // --- HEDEF POZƒ∞SYONLAR ---
    const stbTargets = [];
    const stbColors = [];
    const mazeTargets = [];
    const mazeColors = [];
    let currentTargetPositions = [];
    let currentTargetColors = [];

    // --- DOKU OLU≈ûTURUCU ---
    function getSprite() {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");
      const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, "rgba(255,255,255,1)");
      gradient.addColorStop(0.3, "rgba(200,200,255,0.8)");
      gradient.addColorStop(0.6, "rgba(100,100,255,0.2)");
      gradient.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);
      return new THREE.CanvasTexture(canvas);
    }

    // --- 1. NET STB ---
    function createDenseSTB() {
      const letters = {
        S: [
          [0,1,1,1,1,1,0],
          [1,1,0,0,0,1,1],
          [1,1,0,0,0,0,0],
          [0,1,1,1,1,1,0],
          [0,0,0,0,0,1,1],
          [1,1,0,0,0,1,1],
          [0,1,1,1,1,1,0]
        ],
        T: [
          [1,1,1,1,1,1,1],
          [1,1,1,1,1,1,1],
          [0,0,0,1,0,0,0],
          [0,0,0,1,0,0,0],
          [0,0,0,1,0,0,0],
          [0,0,0,1,0,0,0],
          [0,0,0,1,0,0,0]
        ],
        B: [
          [1,1,1,1,1,1,0],
          [1,1,0,0,0,1,1],
          [1,1,0,0,0,1,1],
          [1,1,1,1,1,1,0],
          [1,1,0,0,0,1,1],
          [1,1,0,0,0,1,1],
          [1,1,1,1,1,1,0]
        ]
      };

      let xOffset = -8;
      const spacing = 6;
      const scale = 0.8;
      let particlesUsed = 0;

      ["S", "T", "B"].forEach((key, lIdx) => {
        const matrix = letters[key];
        const rows = matrix.length;
        const cols = matrix[0].length;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (matrix[r][c]) {
              const density = 45;
              for (let i = 0; i < density; i++) {
                const pt = new THREE.Vector3(
                  xOffset + c * scale + (Math.random() - 0.5) * scale * 0.8,
                  (rows - r) * scale + 2 + (Math.random() - 0.5) * scale * 0.8,
                  (Math.random() - 0.5) * 2.0
                );
                stbTargets.push(pt);
                const mix = lIdx / 2 + (c / cols) * 0.2;
                stbColors.push(
                  CONFIG.colBlue.clone().lerp(CONFIG.colDarkBlue, mix)
                );
                particlesUsed++;
              }
            }
          }
        }
        xOffset += spacing;
      });

      while (stbTargets.length < CONFIG.particleCount) {
        const idx = Math.floor(Math.random() * particlesUsed);
        stbTargets.push(stbTargets[idx].clone());
        stbColors.push(stbColors[idx].clone());
      }
    }
    createDenseSTB();

    // --- 2. STRUCTURED MAZE ---
    function createStructuredMaze() {
      const mazeMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
        [1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
        [1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
        [1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
        [1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
        [1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
        [1,1,1,0,1,0,1,1,1,0,1,1,1,1,1],
        [1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ];

      const rows = mazeMap.length;
      const cols = mazeMap[0].length;
      const scale = 2.5;
      const wallHeight = 2.5;
      const xOff = -(cols * scale) / 2;
      const zOff = -(rows * scale) / 2;

      const wallCells = [];
      const pathCells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (mazeMap[r][c] === 1) wallCells.push({ r, c });
          else pathCells.push({ r, c });
        }
      }

      const wallParticleCount = Math.floor(CONFIG.particleCount * 0.85);
      let pUsed = 0;

      for (let i = 0; i < wallParticleCount; i++) {
        const cell = wallCells[Math.floor(Math.random() * wallCells.length)];
        const pt = new THREE.Vector3(
          xOff + cell.c * scale + (Math.random() - 0.5) * scale,
          (Math.random() - 0.1) * wallHeight,
          zOff + cell.r * scale + (Math.random() - 0.5) * scale
        );
        mazeTargets.push(pt);
        const brightness = pt.y / wallHeight;
        mazeColors.push(
          CONFIG.colDarkBlue.clone().lerp(CONFIG.colBlue, brightness)
        );
        pUsed++;
      }

      for (let i = pUsed; i < CONFIG.particleCount; i++) {
        const cell = pathCells[Math.floor(Math.random() * pathCells.length)];
        const pt = new THREE.Vector3(
          xOff + cell.c * scale + (Math.random() - 0.5) * scale * 0.8,
          0.5 + (Math.random() - 0.5) * 0.5,
          zOff + cell.r * scale + (Math.random() - 0.5) * scale * 0.8
        );
        mazeTargets.push(pt);
        mazeColors.push(CONFIG.colAgent.clone());
      }
    }
    createStructuredMaze();

    // --- PAR√áACIK Sƒ∞STEMƒ∞ ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);
    const phases = new Float32Array(CONFIG.particleCount);

    for (let i = 0; i < CONFIG.particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      colors[i * 3] = CONFIG.colBlue.r;
      colors[i * 3 + 1] = CONFIG.colBlue.g;
      colors[i * 3 + 2] = CONFIG.colBlue.b;
      phases[i] = Math.random() * Math.PI * 2;
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute("phase", new THREE.BufferAttribute(phases, 1));

    const material = new THREE.PointsMaterial({
      size: CONFIG.particleSize,
      map: getSprite(),
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- ANIMASYON ---
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      const now = Date.now();
      const elapsed = now - lastStateTime;
      const time = now * 0.001;

      const posArr = particles.geometry.attributes.position.array;
      const colArr = particles.geometry.attributes.color.array;
      const phArr = particles.geometry.attributes.phase.array;

      switch (currentState) {
        case STATES.FORM_STB:
          currentTargetPositions = stbTargets;
          currentTargetColors = stbColors;
          if (elapsed > 2500) { currentState = STATES.HOLD_STB; lastStateTime = now; }
          break;
        case STATES.HOLD_STB:
          if (elapsed > 3000) { currentState = STATES.TO_MAZE; lastStateTime = now; }
          break;
        case STATES.TO_MAZE:
          currentTargetPositions = mazeTargets;
          currentTargetColors = mazeColors;
          if (elapsed > 2500) { currentState = STATES.MAZE_ACTIVE; lastStateTime = now; }
          break;
        case STATES.MAZE_ACTIVE:
          if (elapsed > 5000) { currentState = STATES.TO_RESET; lastStateTime = now; }
          break;
        case STATES.TO_RESET:
          currentTargetPositions = stbTargets;
          currentTargetColors = stbColors;
          if (elapsed > 2500) { currentState = STATES.HOLD_STB; lastStateTime = now; }
          break;
      }

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const ix = i * 3;
        const tx = currentTargetPositions[i].x;
        const ty = currentTargetPositions[i].y;
        const tz = currentTargetPositions[i].z;
        const tr = currentTargetColors[i].r;
        const tg = currentTargetColors[i].g;
        const tb = currentTargetColors[i].b;

        let speed = CONFIG.speed;
        let noiseX = 0, noiseZ = 0;

        if (currentState === STATES.MAZE_ACTIVE || currentState === STATES.TO_MAZE) {
          if (colArr[ix] > 0.8 && colArr[ix + 1] < 0.3) {
            speed = 0.05;
            const dir = i % 2 === 0 ? 1 : -1;
            if (i % 3 === 0)
              noiseX = Math.sin(time * 5 + phArr[i]) * 1.5 * dir;
            else
              noiseZ = Math.cos(time * 5 + phArr[i]) * 1.5 * dir;
          }
        } else {
          noiseX = Math.sin(time * 3 + phArr[i]) * 0.02;
          noiseZ = Math.cos(time * 2 + phArr[i]) * 0.02;
        }

        posArr[ix]     += (tx - posArr[ix]) * speed + noiseX;
        posArr[ix + 1] += (ty - posArr[ix + 1]) * speed;
        posArr[ix + 2] += (tz - posArr[ix + 2]) * speed + noiseZ;

        colArr[ix]     += (tr - colArr[ix]) * speed;
        colArr[ix + 1] += (tg - colArr[ix + 1]) * speed;
        colArr[ix + 2] += (tb - colArr[ix + 2]) * speed;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;

      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      const size = getSize();
      w = size.w;
      h = size.h;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    animate();
  </script>
</body>
</html>